---
- name: Configure ETCD on multiple hosts
  hosts: etcd_nodes
  become: yes  # Ensures commands are run as a superuser
  vars:
    NAMES: [etcd01, etcd02, etcd03]
    HOSTS: ["10.10.1.1", "10.10.1.2", "10.10.1.3"]
    value_string: ""
  tasks:
    
    - name: Gather hostnames and IPs
      set_fact:
        NAMES: "{{ NAMES + [inventory_hostname] }}"
        HOSTS: "{{ HOSTS + [ansible_host] }}"

    - name: Generate the value string for all hosts
      set_fact:
        value_string: "{{ value_string | default('') + (', ' if value_string else '') + item_name + '=https://' + item_host + ':2380' }}"
      loop: "{{ range(0, groups['etcd_nodes']|length) | map('int') | list }}"  # Using etcd_nodes group
      vars:
        item_name: "{{ hostvars[groups['etcd_nodes'][item]].inventory_hostname }}"  # Using etcd_nodes group
        item_host: "{{ hostvars[groups['etcd_nodes'][item]].ansible_host }}"  # Using etcd_nodes group

    - name: Reload systemd daemon and enable containerd
      shell: |
        systemctl daemon-reload
        systemctl enable --now containerd

    - name: Disable swap temporarily
      command: swapoff -a

    - name: Remove swap entries from /etc/fstab
      replace:
        path: /etc/fstab
        regexp: '^(.*\s+swap\s+.*)$'
        replace: '# \1'
      notify: Reboot if necessary

    - name: Verify swap is disabled
      shell: free -h | grep -i swap
      register: swap_status
      ignore_errors: true

    - debug:
        msg: "Swap status: {{ swap_status.stdout | default('No swap enabled') }}"

    - name: Install kubeadm, kubelet, and kubectl
      apt:
        name: "{{ item }}"
        state: present
      with_items:
        - kubeadm
        - kubelet
        - kubectl

    - name: Setup CRI
      copy:
        dest: /etc/containerd/config.toml
        content: |
          [plugins]
            [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
              [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
                SystemdCgroup = true
        owner: root
        group: root
        mode: '0644'
    
    - name: Create the directory for kubelet configuration
      file:
        path: /etc/systemd/system/kubelet.service.d/
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: Add kubelet Configuration file
      copy:
        dest: /etc/systemd/system/kubelet.service.d/kubelet.conf
        content: |
          apiVersion: kubelet.config.k8s.io/v1beta1
          kind: KubeletConfiguration
          authentication:
            anonymous:
              enabled: false
            webhook:
              enabled: false
          authorization:
            mode: AlwaysAllow
          cgroupDriver: systemd
          address: 127.0.0.1
          containerRuntimeEndpoint: unix:///var/run/containerd/containerd.sock
          staticPodPath: /etc/kubernetes/manifests
        owner: root
        group: root
        mode: '0644'

    - name: Add kubeadm initConfiguration file
      copy:
        dest: /etc/kubernetes/initConfiguration.yaml
        content: |
          ---
          apiVersion: "kubeadm.k8s.io/v1beta4"
          kind: InitConfiguration
          nodeRegistration:
              name: ${NAME}
          localAPIEndpoint:
              advertiseAddress: ${HOST}
          ---
          apiVersion: "kubeadm.k8s.io/v1beta4"
          kind: ClusterConfiguration
          etcd:
              local:
                  serverCertSANs:
                  - "{{ ansible_host }}"
                  peerCertSANs:
                  - "{{ ansible_host }}"
                  extraArgs:
                  - name: initial-cluster
                    value: {{ value_string }}
                  - name: initial-cluster-state
                    value: new
                  - name: name
                    value: ${NAME}
                  - name: listen-peer-urls
                    value: https://"{{ ansible_host }}":2380
                  - name: listen-client-urls
                    value: https://"{{ ansible_host }}":2379
                  - name: advertise-client-urls
                    value: https://"{{ ansible_host }}":2379
                  - name: initial-advertise-peer-urls
                    value: https://"{{ ansible_host }}":2380
        owner: root
        group: root
        mode: '0644'

    - name: Verify kubeadm initConfiguration file
      shell: cat /etc/kubernetes/initConfiguration.yaml
      register: verify_output

## Setup Certificates:
    - name: Check if ca.crt exists
      stat:
        path: /etc/kubernetes/pki/etcd/ca.crt
      register: ca_crt

    - name: Check if peer exists
      stat:
        path: /tmp/{{ inventory_hostname }}/kubeadmcfg.yaml
      register: peer_crt

    - name: Run kubeadm init phase certs etcd-ca on etcd01
      command: kubeadm init phase certs etcd-ca
      when: inventory_hostname == 'etcd01' and not ca_crt.stat.exists
    
    - name: Create Peers Certs on etcd01
      command: |
        mkdir -p /etc/kubernetes/pki/etcd
        mkdir -p /tmp/{{ inventory_hostname }}
        kubeadm init phase certs etcd-server --config=/tmp/{{ inventory_hostname }}/kubeadmcfg.yaml
        kubeadm init phase certs etcd-peer --config=/tmp/{{ inventory_hostname }}/kubeadmcfg.yaml
        kubeadm init phase certs etcd-healthcheck-client --config=/tmp/{{ inventory_hostname }}/kubeadmcfg.yaml
        kubeadm init phase certs apiserver-etcd-client --config=/tmp/{{ inventory_hostname }}/kubeadmcfg.yaml
        cp -R /etc/kubernetes/pki /tmp/{{ inventory_hostname }}/
        # cleanup non-reusable certificates
        find /etc/kubernetes/pki -not -name ca.crt -not -name ca.key -type f -delete
      when: inventory_hostname == 'etcd01' and not peer_crt.stat.exists

    # Step 2: Copy certs to other hosts (excluding etcd01)
    - name: Copy generated certs from etcd01 to other hosts
      copy:
        src: "/tmp/{{ inventory_hostname }}/*"
        dest: "/etc/kubernetes/"
        owner: root
        group: root
        mode: '0644'
      when: inventory_hostname != 'etcd01'
      delegate_to: etcd01

  handlers:
    - name: Reboot if necessary
      command: reboot
      when: reboot_required | default(false)
